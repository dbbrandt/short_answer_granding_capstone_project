5.4 The base case for a recursive merge sort is one number.  One number by itself is a sorted list, regardless of what number it is.
5.4 The base case for a recursive implementation of merge sort is when the sequence being passed to merge sort has less than 2 elements.
5.4 The base case for a recursive implementation of merge sort is one.
5.4 The best case is the same as the worst case O(n log n) for a recursive merge sort.
5.4 there is one object in the split array to sort.
5.4 The base case is when the length of the current array is 1.
5.4 O(nlog(n))
5.4 Best case is one element.  One element is sorted.
5.4 If the array being sorted has 0 or 1 elements
5.4 T(n) = 0, if n&lt;2.
5.4 A list size of 1, where it is already sorted.
5.4 Single element in the array
5.4 O(nlog(n))
5.4 n * log( n )
5.4 A list or array of only 1 element.
5.4 where you only must merge sort once
5.4 A single Element on the Array.
5.4 There is only one element in the subarray.
5.4 if the array length is less than or equal to 1, then that array is returned to the other array and merged together
5.4 if (right &gt; left)<br>  {<br>    mid = (right + left) / 2;<br>    m_sort(numbers, temp, left, mid);<br>    m_sort(numbers, temp, mid+1, right);<br><br>    merge(numbers, temp, left, mid+1, right);<br>  }<br>
5.4 The sequence of numbers has zero or one elements.
5.4 one element in an array
5.4 array of length 1
5.4 the array has one element
5.4 When there is only one element in the array, or when the starting element in the array is the same as the ending element.
5.4 when each half or the original array has nothing else to sort, and puts the halfs back together
5.4 the size of the list being sent is &lt;= 1
5.4 O(n log n)
