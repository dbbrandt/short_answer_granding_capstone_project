3.3 It expands the function 's definition in that place. <STOP> Once the functions is called you can use it as many times as you need. <STOP> The compiler just expands on the function. <STOP>
3.3 When the compiler inline-expands a function call, the function 's code gets inserted into the caller 's code stream -LRB- conceptually similar to what happens with a define macro -RRB- . <STOP> This can, depending on a zillion other things, improve performance, because the optimizer can procedurally integrate the called code optimize the called code into the caller. <STOP>
3.3 The inline keyword advises the compiler to copy the function 's code in place to avoid function calls; however the compiler can and typically does ignore the inline qualifier for all but the smallest functions. <STOP>
3.3 The compiler can ignore the inline qualifier and typically does so for all but the smallest functions. <STOP>
3.3 Placing the qualifier inline before a function 's return type in the function definition "advises" the compiler to generate a copy of the function 's code in place to avoid a function call. <STOP>
3.3 You declare your inline function in the header or before your int main -LRB- -RRB- . <STOP> You then can call that function at anytime in your main program quickly and easily. <STOP>
3.3 It expands a small function out ... making your code longer, but also makes it run faster. <STOP>
3.3 the function is not treated as a separate unit like other functions <STOP>
3.3 When the program compiles, it will copy the function inplace, avoiding a function call. <STOP>
3.3 It replaces all instances of that function call with the inline code itself, resulting in longer but faster programs. <STOP>
3.3 The compiler can ignore the inline qualifier and typically does so for all but the smallest functions. <STOP>
3.3 Ignores the inline qualifier and typically does so for all but the smallest functions. <STOP>
3.3 If the function is small enough it will expand it but it will run faster as it will avoid making so many calls to the function. <STOP>
3.3 it treats them as the same function <STOP>
3.3 Inline functions are copied in place, instead of being referenced. <STOP>
3.3 For inline functions, the compiler creates a copy of the function 's code in place so it does not have to make a function call and add to the function call stack. <STOP>
3.3 it generates a copy of the function 's coding which eliminates calling the function <STOP>
3.3 not answered <STOP>
3.3 It generates a copy of the function 's code by by inserting it in the program. <STOP>
3.3 tells the compiler to make a copy of function 's code in place to avoid a function call. it typically ignores it, except for the smallest functions. <STOP>
3.3 The compiler can ignore the inline qualifier and typically does so for all but the smallest functions. <STOP>
3.3 Multiple copies of the function code are inserted into the program, making it bigger. <STOP>
3.3 compiler ignores inline qualifier <STOP>
3.3 It generates a copy of the function, if it is needed again. <STOP>
3.3 The complier includes copies of inline functions instead of making function calls, but usually only with very small functions. <STOP>
3.3 Compiler generate a copy of the function 's code in place -LRB- when appropriate -RRB- to avoid a function call <STOP>
3.3 instead of calling the function every time it is invoked, the compiler will replace the function call with a copy of the function body <STOP>
3.3 Expands the function into the program <STOP>
3.3 it generates a copy of the functions code in place to avoid a function call <STOP>
3.3 the function call will be replaced by the code that was defined in the inline function <STOP>
3.3 When the compiler inline-expands a function call, the function 's code gets inserted into the caller 's code stream -LRB- conceptually similar to what happens with a define macro -RRB- . <STOP> This can, depending on a zillion other things, improve performance, because the optimizer can procedurally integrate the called code optimize the called code into the caller. <STOP>
